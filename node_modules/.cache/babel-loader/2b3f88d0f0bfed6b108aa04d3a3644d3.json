{"ast":null,"code":"'use strict';\n\nvar parseString = require('string-template');\n\nfunction logError(err) {\n  if (err) {\n    console.error(err);\n  }\n}\n\nfunction createCallback(callback) {\n  return typeof callback === 'function' ? callback : logError;\n}\n\nfunction getMissingParams(params, required) {\n  var missing = [];\n  required.forEach(function (param) {\n    // Is the required param in the params object?\n    if (!params[param]) {\n      missing.push(param);\n    }\n  }); // If there are any required params missing, return their names in array, otherwise return null\n\n  return missing.length > 0 ? missing : null;\n}\n\nfunction DefaultTransporter() {}\n\n;\n\nDefaultTransporter.prototype.request = function (opts, auth, opt_callback) {\n  const url = (opts.uri || opts.url) + '?key=' + auth;\n  let err = false;\n  let response = null;\n  return fetch(url, opts).then(result => {\n    response = result;\n    err = result.ok !== true;\n    return result.text();\n  }).then(text => {\n    this.wrapCallback_(opt_callback)(err, response, text);\n  });\n};\n/**\n * Wraps the response callback.\n * @param {Function=} opt_callback Optional callback.\n * @return {Function} Wrapped callback function.\n * @private\n */\n\n\nDefaultTransporter.prototype.wrapCallback_ = function (opt_callback) {\n  return function (err, res, body) {\n    if (err || !body) {\n      return opt_callback && opt_callback(err, body, res);\n    } // Only and only application/json responses should\n    // be decoded back to JSON, but there are cases API back-ends\n    // responds without proper content-type.\n\n\n    try {\n      body = JSON.parse(body);\n    } catch (err) {\n      /* no op */\n    }\n\n    if (body && body.error && res.statusCode !== 200) {\n      if (typeof body.error === 'string') {\n        err = new Error(body.error);\n        err.code = res.statusCode;\n      } else if (Array.isArray(body.error.errors)) {\n        err = new Error(body.error.errors.map(function (err) {\n          return err.message;\n        }).join('\\n'));\n        err.code = body.error.code;\n        err.errors = body.error.errors;\n      } else {\n        err = new Error(body.error.message);\n        err.code = body.error.code || res.statusCode;\n      }\n\n      body = null;\n    } else if (res.statusCode >= 500) {\n      // Consider all '500 responses' errors.\n      err = new Error(body);\n      err.code = res.statusCode;\n      body = null;\n    }\n\n    if (opt_callback) {\n      opt_callback(err, body, res);\n    }\n  };\n};\n/**\n * Create and send request to Google API\n * @param  {object}   parameters Parameters used to form request\n * @param  {Function} callback   Callback when request finished or error found\n * @return {Request}             Returns Request object or null\n */\n\n\nfunction createAPIRequest(parameters, callback) {\n  var req, body, missingParams;\n  var params = parameters.params;\n  var options = Object.assign({}, parameters.options); // If the params are not present, and callback was passed instead,\n  // use params as the callback and create empty params.\n\n  if (typeof params === 'function') {\n    callback = params;\n    params = {};\n  } // Create a new params object so it can no longer be modified from outside code\n  // Also support global and per-client params, but allow them to be overriden per-request\n\n\n  params = Object.assign({}, // New base object\n  params // API call params\n  );\n  var media = params.media || {};\n  var resource = params.resource;\n  var authClient = params.auth;\n  var defaultMime = 'text/plain';\n  delete params.media;\n  delete params.resource;\n  delete params.auth; // Grab headers from user provided options\n\n  var headers = params.headers || {};\n  delete params.headers; // Un-alias parameters that were modified due to conflicts with reserved names\n\n  Object.keys(params).forEach(function (key) {\n    if (key.slice(-1) === '_') {\n      var newKey = key.slice(0, -1);\n      params[newKey] = params[key];\n      delete params[key];\n    }\n  }); // Normalize callback\n\n  callback = createCallback(callback); // Check for missing required parameters in the API request\n\n  missingParams = getMissingParams(params, parameters.requiredParams);\n\n  if (missingParams) {\n    // Some params are missing - stop further operations and inform the developer which required\n    // params are not included in the request\n    callback(new Error('Missing required parameters: ' + missingParams.join(', ')));\n    return null;\n  } // delete path parameters from the params object so they do not end up in query\n\n\n  parameters.pathParams.forEach(function (param) {\n    delete params[param];\n  }); // if authClient is actually a string, use it as an API KEY\n\n  if (typeof authClient === 'string') {\n    params.key = params.key || authClient;\n    authClient = null;\n  }\n\n  if (parameters.bodyJSON) {\n    options.body = JSON.stringify(parameters.data);\n  }\n\n  options.headers = headers;\n  options = Object.assign({}, parameters.context.google._options, parameters.context._options, options);\n  const auth = options.auth;\n  delete options.auth;\n  delete options.params; // We handle params ourselves and Request does not recognise 'params'\n  // create request (using authClient or otherwise and return request obj)\n\n  if (authClient) {\n    req = authClient.request(options, callback);\n  } else {\n    req = new DefaultTransporter().request(options, auth, callback);\n  }\n\n  if (body) {\n    body.pipe(req);\n  }\n\n  return req;\n}\n/**\n * Exports createAPIRequest\n * @type {Function}\n */\n\n\nmodule.exports = createAPIRequest;","map":null,"metadata":{},"sourceType":"script"}